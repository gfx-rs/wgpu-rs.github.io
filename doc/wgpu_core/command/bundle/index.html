<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Render Bundles"><title>wgpu_core::command::bundle - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-1a91846b.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="wgpu_core" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0 (6b00bc388 2025-06-23)" data-channel="1.88.0" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../../../static.files/storage-4e99c027.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../wgpu_core/index.html">wgpu_<wbr>core</a><span class="version">27.0.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module bundle</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#render-bundle-isolation" title="Render Bundle Isolation">Render Bundle Isolation</a></li><li><a href="#render-bundle-lifecycle" title="Render Bundle Lifecycle">Render Bundle Lifecycle</a></li><li><a href="#implementation" title="Implementation">Implementation</a><ul><li><a href="#execution" title="Execution">Execution</a></li></ul></li></ul><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In wgpu_<wbr>core::<wbr>command</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">wgpu_core</a>::<wbr><a href="../index.html">command</a></div><h1>Module <span>bundle</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/wgpu_core/command/bundle.rs.html#1-1873">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Render Bundles</p>
<p>A render bundle is a prerecorded sequence of commands that can be replayed on a
command encoder with a single call. A single bundle can replayed any number of
times, on different encoders. Constructing a render bundle lets <code>wgpu</code> validate
and analyze its commands up front, so that replaying a bundle can be more
efficient than simply re-recording its commands each time.</p>
<p>Not all commands are available in bundles; for example, a render bundle may not
contain a [<code>RenderCommand::SetViewport</code>] command.</p>
<p>Most of <code>wgpu</code>’s backend graphics APIs have something like bundles. For example,
Vulkan calls them “secondary command buffers”, and Metal calls them “indirect
command buffers”. Although we plan to take advantage of these platform features
at some point in the future, for now <code>wgpu</code>’s implementation of render bundles
does not use them: at the hal level, <code>wgpu</code> render bundles just replay the
commands.</p>
<h3 id="render-bundle-isolation"><a class="doc-anchor" href="#render-bundle-isolation">§</a>Render Bundle Isolation</h3>
<p>One important property of render bundles is that the draw calls in a render
bundle depend solely on the pipeline and state established within the render
bundle itself. A draw call in a bundle will never use a vertex buffer, say, that
was set in the <code>RenderPass</code> before executing the bundle. We call this property
‘isolation’, in that a render bundle is somewhat isolated from the passes that
use it.</p>
<p>Render passes are also isolated from the effects of bundles. After executing a
render bundle, a render pass’s pipeline, bind groups, and vertex and index
buffers are are unset, so the bundle cannot affect later draw calls in the pass.</p>
<p>A render pass is not fully isolated from a bundle’s effects on push constant
values. Draw calls following a bundle’s execution will see whatever values the
bundle writes to push constant storage. Setting a pipeline initializes any push
constant storage it could access to zero, and this initialization may also be
visible after bundle execution.</p>
<h3 id="render-bundle-lifecycle"><a class="doc-anchor" href="#render-bundle-lifecycle">§</a>Render Bundle Lifecycle</h3>
<p>To create a render bundle:</p>
<ol>
<li>
<p>Create a <a href="../struct.RenderBundleEncoder.html" title="struct wgpu_core::command::RenderBundleEncoder"><code>RenderBundleEncoder</code></a> by calling
<a href="../../global/struct.Global.html#method.device_create_render_bundle_encoder" title="method wgpu_core::global::Global::device_create_render_bundle_encoder"><code>Global::device_create_render_bundle_encoder</code></a>.</p>
</li>
<li>
<p>Record commands in the <code>RenderBundleEncoder</code> using functions from the
<a href="../bundle_ffi/index.html" title="mod wgpu_core::command::bundle_ffi"><code>bundle_ffi</code></a> module.</p>
</li>
<li>
<p>Call <a href="../../global/struct.Global.html#method.render_bundle_encoder_finish" title="method wgpu_core::global::Global::render_bundle_encoder_finish"><code>Global::render_bundle_encoder_finish</code></a>, which analyzes and cleans up
the command stream and returns a <code>RenderBundleId</code>.</p>
</li>
<li>
<p>Then, any number of times, call <a href="../../global/struct.Global.html#method.render_pass_execute_bundles" title="method wgpu_core::global::Global::render_pass_execute_bundles"><code>render_pass_execute_bundles</code></a> to
execute the bundle as part of some render pass.</p>
</li>
</ol>
<h3 id="implementation"><a class="doc-anchor" href="#implementation">§</a>Implementation</h3>
<p>The most complex part of render bundles is the “finish” step, mostly implemented
in <a href="../struct.RenderBundleEncoder.html#method.finish" title="method wgpu_core::command::RenderBundleEncoder::finish"><code>RenderBundleEncoder::finish</code></a>. This consumes the commands stored in the
encoder’s [<code>BasePass</code>], while validating everything, tracking the state,
dropping redundant or unnecessary commands, and presenting the results as a new
<a href="../struct.RenderBundle.html" title="struct wgpu_core::command::RenderBundle"><code>RenderBundle</code></a>. It doesn’t actually execute any commands.</p>
<p>This step also enforces the ‘isolation’ property mentioned above: every draw
call is checked to ensure that the resources it uses on were established since
the last time the pipeline was set. This means the bundle can be executed
verbatim without any state tracking.</p>
<h4 id="execution"><a class="doc-anchor" href="#execution">§</a>Execution</h4>
<p>When the bundle is used in an actual render pass, <code>RenderBundle::execute</code> is
called. It goes through the commands and issues them into the native command
buffer. Thanks to isolation, it doesn’t track any bind group invalidations or
index format changes.</p>
<p>!</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="bundle_ffi/index.html" title="mod wgpu_core::command::bundle::bundle_ffi">bundle_<wbr>ffi</a></dt></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.BindState.html" title="struct wgpu_core::command::bundle::BindState">Bind<wbr>State</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>A bind group that has been set at a particular index during render bundle encoding.</dd><dt><a class="struct" href="struct.IndexState.html" title="struct wgpu_core::command::bundle::IndexState">Index<wbr>State</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>A render bundle’s current index buffer state.</dd><dt><a class="struct" href="struct.PipelineState.html" title="struct wgpu_core::command::bundle::PipelineState">Pipeline<wbr>State</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>The bundle’s current pipeline, and some cached information needed for validation.</dd><dt><a class="struct" href="struct.RenderBundle.html" title="struct wgpu_core::command::bundle::RenderBundle">Render<wbr>Bundle</a></dt><dd>cbindgen:ignore</dd><dt><a class="struct" href="struct.RenderBundleEncoder.html" title="struct wgpu_core::command::bundle::RenderBundleEncoder">Render<wbr>Bundle<wbr>Encoder</a></dt><dt><a class="struct" href="struct.RenderBundleEncoderDescriptor.html" title="struct wgpu_core::command::bundle::RenderBundleEncoderDescriptor">Render<wbr>Bundle<wbr>Encoder<wbr>Descriptor</a></dt><dd>Describes a <a href="../struct.RenderBundleEncoder.html" title="struct wgpu_core::command::RenderBundleEncoder"><code>RenderBundleEncoder</code></a>.</dd><dt><a class="struct" href="struct.RenderBundleError.html" title="struct wgpu_core::command::bundle::RenderBundleError">Render<wbr>Bundle<wbr>Error</a></dt><dd>Error encountered when finishing recording a render bundle.</dd><dt><a class="struct" href="struct.State.html" title="struct wgpu_core::command::bundle::State">State</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>State for analyzing and cleaning up bundle command streams.</dd><dt><a class="struct" href="struct.VertexState.html" title="struct wgpu_core::command::bundle::VertexState">Vertex<wbr>State</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>The state of a single vertex buffer slot during render bundle encoding.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.CreateRenderBundleError.html" title="enum wgpu_core::command::bundle::CreateRenderBundleError">Create<wbr>Render<wbr>Bundle<wbr>Error</a></dt><dd>Error type returned from <code>RenderBundleEncoder::new</code> if the sample count is invalid.</dd><dt><a class="enum" href="enum.ExecutionError.html" title="enum wgpu_core::command::bundle::ExecutionError">Execution<wbr>Error</a></dt><dd>Error type returned from <code>RenderBundleEncoder::new</code> if the sample count is invalid.</dd><dt><a class="enum" href="enum.RenderBundleErrorInner.html" title="enum wgpu_core::command::bundle::RenderBundleErrorInner">Render<wbr>Bundle<wbr>Error<wbr>Inner</a></dt><dd>Error encountered when finishing recording a render bundle.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.draw.html" title="fn wgpu_core::command::bundle::draw">draw</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.draw_indexed.html" title="fn wgpu_core::command::bundle::draw_indexed">draw_<wbr>indexed</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.draw_mesh_tasks.html" title="fn wgpu_core::command::bundle::draw_mesh_tasks">draw_<wbr>mesh_<wbr>tasks</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.multi_draw_indirect.html" title="fn wgpu_core::command::bundle::multi_draw_indirect">multi_<wbr>draw_<wbr>indirect</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.set_bind_group.html" title="fn wgpu_core::command::bundle::set_bind_group">set_<wbr>bind_<wbr>group</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.set_index_buffer.html" title="fn wgpu_core::command::bundle::set_index_buffer">set_<wbr>index_<wbr>buffer</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.set_pipeline.html" title="fn wgpu_core::command::bundle::set_pipeline">set_<wbr>pipeline</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.set_push_constant.html" title="fn wgpu_core::command::bundle::set_push_constant">set_<wbr>push_<wbr>constant</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.set_vertex_buffer.html" title="fn wgpu_core::command::bundle::set_vertex_buffer">set_<wbr>vertex_<wbr>buffer</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.RenderBundleDescriptor.html" title="type wgpu_core::command::bundle::RenderBundleDescriptor">Render<wbr>Bundle<wbr>Descriptor</a></dt></dl></section></div></main></body></html>