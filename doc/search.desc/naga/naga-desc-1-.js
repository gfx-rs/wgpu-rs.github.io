searchState.loadedDescShard("naga", 1, "Splat scalar into a vector.\nInstructions which make up an executable block.\nStorage buffer data, potentially mutable.\nStorage image.\nFlags describing an image.\nImage storage format.\nStores a value at an address.\nUser-defined structure.\nMember of a user-defined structure.\nCalculate a bitmask using a boolean from each active …\nResult of a <code>SubgroupBallot</code> statement.\nCompute a collective operation across all active threads …\nGather a value from another active thread in the subgroup\nRead in compute, task, and mesh shaders\nRead in compute, fragment, task, and mesh shaders\nResult of a <code>SubgroupCollectiveOperation</code> or <code>SubgroupGather</code> …\nRead in compute, fragment, task, and mesh shaders\nConditionally executes one of multiple blocks, based on …\nA case for a switch statement.\nThe value of the switch case.\nVector swizzle.\nComponent selection for a vector swizzle.\nStop traversal after the first hit.\nBarrier synchronizes texture memory accesses in a …\nA task shader, in a mesh render pipeline.\nTask shader to mesh shader payload\n3D vector\nIntersecting with triangles. Matches …\nWritten in mesh shaders\nOutputs groups of 3 vertices to be rendered as triangles.\nA data type declared in the module.\nEnum with additional information, depending on the kind of …\nUnsigned integer type.\nApply an unary operator.\nOperation that can be applied on a single value.\nShader may not rewrite depth value.\nUniform buffer data.\nPointer to a scalar or vector.\nVector of numbers.\nNumber of components in a vector.\nA vertex shader, in a render pipeline.\nWritten to a workgroup variable in mesh shaders\nRead in vertex shaders\nWritten to a workgroup variable in mesh shaders\nRead in task, mesh, vertex, and fragment shaders\nBarrier affects all <code>AddressSpace::WorkGroup</code> accesses.\nWorkgroup shared data, mutable.\nRead in compute, task, and mesh shaders\nRead in compute, task, and mesh shaders\nLoad uniformly from a uniform pointer in the workgroup …\nResult of a <code>WorkGroupUniformLoad</code> statement.\nZero value of a type.\nHelper function, to create a function prototype for a …\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nExtracts mesh shader info from a mesh output global …\nApply the usual default interpolation for <code>ty</code> to <code>binding</code>.\nInformation about function argument.\nFind the common type of <code>self</code> and <code>other</code> under WGSL’s …\nReturn <code>true</code> if automatic conversions will covert <code>self</code> to …\nDetermine whether <code>self</code> automatically converts to <code>goal</code>.\nReturns the ref count, upon reaching which this expression …\nFor I/O structs, defines the binding.\nBinding number within the group.\nFor resources, defines the binding point.\nFor entry points, an argument has to have a binding unless …\nFor entry points, the result has to have a binding unless …\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nGet the underlying bits value.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nBody of the case.\nBlock of instructions comprising the body of the function.\nReturn the canonical form of <code>self</code>, or <code>None</code> if it’s …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nArena for the constants defined in this module.\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nThe leaf of all diagnostic filter rules tree (stored in …\nThe leaf of all diagnostic filter rules tree parsed from …\nArena for all diagnostic filter rules parsed in this …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nDoc comments.\nEarly depth test for fragment stages.\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nEntry points.\nExpressions used inside this function.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nStruct containing parameters required by some backends to …\nStruct describing a gamma encoding transfer function. …\nIf true, the control flow continues to the next case in …\nConstruct a float <code>Scalar</code> with the given width.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nThe entrance function.\nArena for the functions defined in this module.\nGenerate <code>SpecialTypes::external_texture_params</code> and …\nPopulate this module’s <code>SpecialTypes::predeclared_types</code> …\nPopulate this module’s <code>SpecialTypes::ray_desc</code> type.\nPopulate this module’s <code>SpecialTypes::ray_intersection</code> …\nMake sure the types for the vertex return are in the module…\nConstant expressions and override expressions used by this …\nArena for the global variables defined in this module.\nThe bind group index.\nUsed to generate the name of the wrapped type constructor\nPipeline Constant ID.\nReturn the <code>ImageDimension</code> for which <code>self</code> is an appropriate …\nReturn the length of a subscriptable type.\nReturn the length of <code>self</code>, assuming overrides are yet to …\nReturn the length of <code>self</code>, assuming overrides have been …\nThe default value of the pipeline-overridable constant.\nThe value of the constant.\nInitial value for this variable.\nInitial value for this variable.\nWhether a variable with this address space can be …\nInner structure that depends on the kind of the type.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn true if <code>self</code> is an abstract type.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nReturn true if this expression is a dynamic …\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nReturns true if this is a handle to a type rather than the …\nReturns true if the statement directly terminates the …\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nHow the value’s bits are to be interpreted.\nLocal variables defined and used in the function.\nThe maximum number of primitives a mesh shader may output.\nIf pipeline constants are used, the expressions that …\nThe maximum number of vertices a mesh shader may output.\nIf pipeline constants are used, the expressions that …\nInformation for <code>Mesh</code> shaders.\nThe name of the type, if any.\nName of the variable, if any.\nName of the variable, if any.\nName of the argument, if any.\nName of the function, if any.\nName of this entry point, visible externally.\nMap of expressions that have associated variable names\nReturns true if the address space may need a “const” …\nReturns true if global variables in this address space are …\nReturns true if the expression is considered emitted at …\nCompare value type <code>self</code> and <code>rhs</code> as types.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nOffset from the beginning from the struct.\nReturn the global variable being accessed by the …\nThe global variable holding the outputted vertices, …\nArena for the pipeline-overridable constants defined in …\nReturn the leaf scalar type of <code>pointer</code>.\nIf <code>self</code> is a pointer type, return its base type.\nTypes for predeclared wgsl types instantiated on demand.\nThe type used by primitive outputs, i.e. what is passed to …\nType for <code>RayDesc</code>.\nType for <code>RayIntersection</code>.\nType for <code>RayVertexReturn</code>.\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nReturn the number of elements that <code>size</code> represents, if …\nThe result of this function, if any.\nReturn the scalar type of <code>self</code>.\nReturn the leaf scalar type of <code>self</code>, as needed for …\nReturns the scalar width in bytes\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nReturns <code>true</code> if there is just one component, otherwise …\nGet the size of this type.\nHow this variable is to be stored.\nDictionary of special type handles.\nShader stage.\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe unique global variable used as a task payload from …\nHelper function that returns scalar related strings\nReturn the string corresponding to the HLSL interpolation …\nReturn the HLSL auxiliary qualifier for the given sampling …\nReturn the HLSL suffix for the <code>InterlockedXxx</code> method.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe type of primitive outputted.\nAttempt to calculate the size of this type. Returns <code>None</code> …\nType of the field.\nThe type of this variable.\nThe type of this variable.\nType of the argument.\nType of the result.\nArena for the types defined in this module.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nUpgrade <code>global_var_handles</code> to have <code>Atomic</code> leaf types.\nValue, upon which the case is considered true.\nIf the type is a Vector or a Scalar return a tuple of the …\nThe type used by vertex outputs, i.e. what is passed to …\nThis size of the value in bytes.\nWorkgroup size for compute stages\nOverride expressions for workgroup size in the …\nOptional <code>blend_src</code> index used for dual source blending. …\nWhether the binding is a per-primitive binding for use …\nSpecifies restrictions on how the depth value can be …\nThe index into an arrayed image. If the <code>arrayed</code> flag in …\nWhether the sampling operation should clamp each component …\nBoolean expression\nIf provided, converts to the specified byte width. …\nThe coordinate of the texel we wish to load. This must be …\nSource expression, which can only be a scalar or a vector.\nIf Some(), this operation is a gather operation on the …\nThe image to load a texel from. This must have type <code>Image</code>. …\nTarget scalar kind.\nA level of detail, for mipmapped images.\nThis must be a const-expression.\nA sample index, for multisampled <code>Sampled</code> and <code>Depth</code> images.\nThe type of the result\nKind of values to sample.\nMulti-sampled image.\nMulti-sampled depth image.\nIf <code>None</code>, the base level is considered.\nThe acceleration structure within which this query should …\nA struct of detailed parameters for the ray query.\nThe value to broadcast over\nThe value to compute over\nThe index into an arrayed image. If the <code>arrayed</code> flag in …\nHow to combine the results\nThe coordinate of the texel we wish to load. This must be …\nFunction to run on the atomic value.\nThe kind of atomic operation to perform on the texel.\nThe specific operation we’re performing on <code>query</code>.\nThe image to perform an atomic operation on. This must …\nSpecifies which thread to gather from\nWhat operation to compute\nPointer to an atomic value.\nThis must be of type <code>Pointer</code> in the <code>WorkGroup</code> address space\nThe value from this thread to store in the ballot\nThe <code>RayQuery</code> object this statement operates on.\n<code>AtomicResult</code> expression representing this function’s …\nThe <code>WorkGroupUniformLoadResult</code> expression representing …\nThe <code>SubgroupBallotResult</code> expression representing this load…\nThe <code>SubgroupOperationResult</code> expression representing this …\nThe <code>SubgroupOperationResult</code> expression representing this …\nValue to use in the function.\nThe value with which to perform the atomic operation.\nA code block is a vector of statements, with maybe a …\nKeywords for WGSL (WebGPU Shading Language).\nThe above set of reserved keywords, turned into a cached …\nAn unsigned 32-bit value known not to be <code>u32::MAX</code>.\nReturns the argument unchanged.\nConstruct a <code>NonMaxU32</code> whose value is <code>index</code>.\nReturn the value of <code>self</code> as a <code>u32</code>.\nCalls <code>U::from(self)</code>.\nConstruct a <code>NonMaxU32</code> whose value is <code>n</code>, if possible.\nConstruct a <code>NonMaxU32</code> whose value is <code>n</code>.\nA newtype struct where its only valid values are powers of …\nA case-insensitive, ASCII-only set of strings, for use …\nThe result type of a <code>Rule</code>.\nA context for evaluating constant expressions.\nHelper class to emit expressions\nEntry point version of <code>FunctionOobLocal</code>.\nA function argument holding a component of a lowered …\nA global variable holding a component of a lowered …\nA component of a lowered external texture.\nA local variable used by ReadZeroSkipWrite bounds-check …\nA type stored in the associated arena.\nA case-sensitive set of strings, for use with <code>Namer</code> to …\nErrors generated by the <code>Layouter</code>.\nHelper processor that derives the sizes of all types.\nThis processor assigns names to all the things in a module …\nA trait for types representing of a set of Naga IR type …\nA type that should be registered in the module’s …\nA single type rule.\nSize and alignment information for a type.\nThe result of computing an expression’s type.\nA type that can be entirely characterized by a <code>TypeInner</code> …\nA free-floating <code>TypeInner</code>, representing a type that may …\nReturn a list of the types allowed for argument <code>i</code>.\nFind the overloads that could accept a given argument.\nWhich language’s evaluation rules we should follow.\nCompare two types.\nProduce all concrete integer <code>ir::Scalar</code>s.\nLimit <code>self</code> to overloads whose arguments are all concrete …\nThe module’s constant arena.\nEnsure that the given block has return statements at the …\nTry to evaluate the expression in the <code>arena</code> using its …\nTry to evaluate the expression in <code>self.global_expressions</code> …\nTry to evaluate the expression in the <code>arena</code> using its …\nTracks the constness of expressions residing in …\nThe arena to which we are contributing expressions.\nReturn an iterator over the individual components …\nReturn an object that can be formatted with …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDefinitions for index bounds checking.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn true if <code>self</code> is the empty set of overloads.\nLayouts for types in an arena.\nReturn the largest number of arguments in any type rule in …\nReturn the smallest number of arguments in any type rule …\nReturns a tuple of <code>crate::Literal</code>s representing the …\nReturn the most preferred candidate.\nReturn a type rule for each of the overloads in <code>self</code>.\nOverload resolution for builtin functions.\nThe module’s override arena.\nMethods on or related to <code>TypeInner</code>, <code>Scalar</code>, <code>ScalarKind</code>, …\nThe module’s type arena.\nThe last numeric suffix used for each base name. Zero …\nHelper function that returns the string corresponding to …\nProduce all vector sizes.\nMaps to <code>Literal::AbstractFloat</code>\nMaps to <code>Literal::AbstractFloat</code>\nMaps to <code>Literal::AbstractFloat</code>\nMaps to <code>Literal::AbstractInt</code>\nMaps to <code>Literal::AbstractInt</code>\nA subset of <code>Literal</code>s intended to be used for implementing …\nconst-expressions will be evaluated and inserted in the …\nconst-expressions will be evaluated and inserted in the …\nA context for evaluating constant expressions.\nMaps to <code>Literal::F16</code>\nMaps to <code>Literal::F16</code>\nMaps to <code>Literal::F16</code>\nMaps to <code>Literal::F32</code>\nMaps to <code>Literal::F32</code>\nMaps to <code>Literal::F32</code>\nA subset of <code>Literal</code>s intended to be used for implementing …\nMaps to <code>Literal::I32</code>\nMaps to <code>Literal::I32</code>\nMaps to <code>Literal::I32</code>\nMaps to <code>Literal::I64</code>\nVectors with a concrete element type.\nconst-expressions will be evaluated and inserted in the …\nconst-expressions will be evaluated and inserted in the …\nconst-expressions will be evaluated and inserted in the …\nA subset of <code>Literal</code>s intended to be used for implementing …\nA subset of <code>Literal</code>s intended to be used for implementing …\nTrait for conversions of abstract values to concrete types.\nMaps to <code>Literal::U32</code>\nMaps to <code>Literal::U32</code>\nMaps to <code>Literal::U64</code>\nWhich language’s evaluation rules we should follow.\nConvert the scalar components of <code>expr</code> to <code>target</code>.\nConvert the scalar leaves of  <code>expr</code> to <code>target</code>, handling …\nAttempts to evaluate multiple <code>exprs</code> as a combined …\nA convenience macro for using the same RHS for each …\nAttempts to evaluate multiple <code>exprs</code> as a combined <code>Float</code> to …\nA convenience macro for using the same RHS for each <code>Float</code> …\nAttempts to evaluate multiple <code>exprs</code> as a combined <code>Scalar</code> …\nA convenience macro for using the same RHS for each <code>Scalar</code> …\nAttempts to evaluate multiple <code>exprs</code> as a combined <code>Signed</code> …\nA convenience macro for using the same RHS for each <code>Signed</code> …\nThe module’s constant arena.\nDeep copy <code>expr</code> from <code>expressions</code> into <code>self.expressions</code>.\nVector cross product.\nLower <code>ZeroValue</code> expressions to <code>Literal</code> and <code>Compose</code> …\nLower <code>ZeroValue</code> and <code>Splat</code> expressions to <code>Literal</code> and …\nLower <code>ZeroValue</code> expressions to <code>Literal</code> and <code>Compose</code> …\nTracks the constness of expressions residing in …\nThe arena to which we are contributing expressions.\nExtract the values of a <code>vecN</code> from <code>expr</code>.\nExtract the values of a <code>vecN</code> from <code>expr</code>.\nReturn a <code>ConstantEvaluator</code> that will add expressions to …\nReturn a <code>ConstantEvaluator</code> that will add expressions to …\nReturn a <code>ConstantEvaluator</code> that will add expressions to …\nReturn a <code>ConstantEvaluator</code> that will add expressions to …\nForces the the expression to not be const\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates <code>LiteralVector</code> of size 1 from single <code>Literal</code>\nCreates <code>LiteralVector</code> from <code>ArrayVec</code> of <code>Literal</code>s. Returns …\nGlobal constant expressions\nReturns <code>true</code> if the inner WGSL/GLSL restrictions are …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs the <code>Self::expressions</code> arena the global module …\nA macro for matching on <code>LiteralVector</code> variants.\nThe module’s override arena.\nDot product of two packed vectors (<code>dot4I8Packed</code> and …\nPuts self into eval’s expressions arena and returns …\nSplat <code>value</code> to <code>size</code>, without using <code>Splat</code> expressions.\nReturns <code>ArrayVec</code> of <code>Literal</code>s\nTry to evaluate <code>expr</code> at compile time.\nConvert an abstract literal <code>value</code> to <code>Self</code>.\nThe module’s type arena.\nReturns the total number of components, after flattening, …\nA macro that allows dollar signs (<code>$</code>) to be emitted by …\nHelper class to emit expressions\nItems returned by the <code>bounds_check_iter</code> iterator.\nPolicies for injecting bounds checks during code …\nHow should code generated by Naga do bounds checks?\nThe number of elements is determined at runtime.\nAn index that may be statically known, or may need to be …\nThe number of elements in an indexable type.\nValues of this type always have the given number of …\nOut-of-bounds reads return zero, and writes have no effect.\nReplace out-of-bounds indexes with some arbitrary …\nNaga adds no checks to indexing operations. Generate the …\nDetermine whether <code>index</code> is statically known to be in …\nThe base of the <code>Access</code> or <code>AccessIndex</code> expression.\nHow should the generated code handle binding array indexes …\nReturns an iterator of accesses within the chain of <code>Access</code> …\nHow should the generated code handle array, vector, or …\nDetermine which policy applies to <code>base</code>.\nReturn <code>true</code> if any of <code>self</code>’s policies are <code>policy</code>.\nBuild a set of expressions used as indices, to cache in …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHow should the generated code handle image texel loads …\nThe index being accessed.\nHow should the generated code handle array, vector, or …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe length of <code>base</code>.\nReturns all the types which we need out-of-bounds locals …\nMake a <code>GuardedIndex::Known</code> from a <code>GuardedIndex::Expression</code> …\nA string wrapper type with an ascii case insensitive Eq …\nA case-insensitive, ASCII-only set of strings, for use …\nA case-sensitive set of strings, for use with <code>Namer</code> to …\nReturns whether the set contains the given string.\nReturns whether the set contains the given string, with …\nReturns a reference to the empty set.\nReturns a reference to the empty set.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns a new mutable empty set.\nReturns a new mutable empty set.\nA newtype struct where its only valid values are powers of …\nErrors generated by the <code>Layouter</code>.\nHelper processor that derives the sizes of all types.\nSize and alignment information for a type.\nRemove all entries from this <code>Layouter</code>, retaining storage.\nPanics\nReturns whether or not <code>n</code> is a multiple of this alignment.\nLayouts for types in an arena.\nRound <code>n</code> up to the nearest alignment boundary.\nProduce the stride as if this type is a base of an array.\nExtend this <code>Layouter</code> with layouts for any new entries in …\nEntry point version of <code>FunctionOobLocal</code>.\nA function argument holding a component of a lowered …\nA global variable holding a component of a lowered …\nA component of a lowered external texture.\nA local variable used by ReadZeroSkipWrite bounds-check …\nThis processor assigns names to all the things in a module …\nReturn a new identifier based on <code>label_raw</code>.\nEnter a local namespace for things like structs.\nReturn a form of <code>string</code> suitable for use as the base of an …\nThe last numeric suffix used for each base name. Zero …\nA trait for types representing of a set of Naga IR type …\nReturn a list of the types allowed for argument <code>i</code>.\nDynamically dispatched <code>OverloadSet</code>s.\nFind the overloads that could accept a given argument.\nLimit <code>self</code> to overloads whose arguments are all concrete …\nA set of type constructors, represented as a bitset.\nReturn an object that can be formatted with …\nReturn true if <code>self</code> is the empty set of overloads.\nAn <code>OverloadSet</code> represented as a vector of rules.\nOverload sets for <code>ir::MathFunction</code>.\nReturn the largest number of arguments in any type rule in …\nReturn the smallest number of arguments in any type rule …\nReturn the most preferred candidate.\nAn iterator over bitmasks.\nReturn a type rule for each of the overloads in <code>self</code>.\nA representation for highly regular overload sets common …\nType rules.\nA set of scalar types, represented as a bitset.\nUtility functions for constructing <code>List</code> overload sets.\nAn <code>OverloadSet</code> that dynamically dispatches to concrete …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA set of type constructors.\nThe sizes a member of <code>ConstructorSet</code> might have.\nThe constructor is <code>MATCXR</code> for some <code>C</code> and <code>R</code>.\nThe constructor is <code>SCALAR</code>.\nThe constructor is <code>VECN</code> for some <code>N</code>.\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nReturn an iterator over this set’s members.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nReturn the single-member set containing <code>inner</code>’s …\nReturn the size of the sole element of <code>self</code>.\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nConstruct a <code>TypeInner</code> for a type with this size and the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nA simple list of overloads.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA bitmask of which elements of <code>rules</code> are included in the …\nA list of type rules that are members of the set.\nAn iterator that produces the set bits in the given <code>u64</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConclusion-computing rules.\nOverload sets represented as sets of scalars and …\nThe number of arguments in the rules.\nHow to determine a member rule’s return type given the …\nThe set of type constructors to apply.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a <code>Regular</code> member <code>Rule</code> for the given arity and …\nReturn an iterator over all the argument types allowed by …\nConstruct a <code>Regular</code> <code>OverloadSet</code>.\nThe set of scalars to apply them to.\nThe result type of a <code>Rule</code>.\nA type that should be registered in the module’s …\nA single type rule.\nA type that can be entirely characterized by a <code>TypeInner</code> …\nFloating-point scalars, with the abstract floats omitted …\nA table mapping bit numbers to the <code>Scalar</code> values they …\nA set of scalar types.\nAn enum used to assign distinct bit numbers to <code>ScalarSet</code> …\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nReturn the set of scalars to which <code>scalar</code> can be …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nReturn an iterator over this set’s members.\nReturn the lowest-ranked member of <code>self</code> as a <code>Scalar</code>.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nReturn the set of scalars containing only <code>scalar</code>.\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nProduce all the floating-point <code>ir::Scalar</code>s.\nProduce all the floating-point <code>ir::Scalar</code>s, but omit …\nConstruct a <code>List</code> from the given rules.\nReturn the cartesian product of two iterators.\nConstruct a <code>Rule</code> for an operation with the given argument …\nProduce the scalar and vector <code>ir::TypeInner</code>s that have <code>s</code> as\nReturn the cartesian product of three iterators.\nEnsure that the given block has return statements at the …\nHelper trait for providing the min and max values exactly …\nProduce all concrete integer <code>ir::Scalar</code>s.\nReturns the maximum value exactly representable by the …\nReturns the minimum value exactly representable by the …\nReturns a tuple of <code>crate::Literal</code>s representing the …\nHelper function that returns the string corresponding to …\nProduce all vector sizes.\nA type stored in the associated arena.\nThe result of computing an expression’s type.\nA free-floating <code>TypeInner</code>, representing a type that may …\nCompare two types.\nDetermine the type of <code>expr</code>.\nInitialize a resolve context from the module.\nAn alternative to <code>LazyLock</code> based on <code>OnceBox</code>.\nLoads the internal value, initializing it if required.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new <code>RacyLock</code>, which will initialize using the …\nConvenience trait for <code>Error</code> to be able to apply spans to …\nConvenience trait for <code>Result</code>, adding a …\nThe returned output type.\nThe returned output type.\nA human-readable representation for a span, tailored for …\nA source code span, used for error reporting.\nA source code span together with “context”, a …\nTrait abstracting over getting a span from an <code>Arena</code> or a …\nWrapper class for <code>Error</code>, augmenting it with a list of …\nConvert inner error into another type. Joins span …\nEmits a summary of the error to standard error stream.\nEmits a summary of the error to standard error stream.\nEmits a summary of the error to a string.\nEmits a summary of the error to a string.\nReverse of <code>Self::new</code>, discards span information and …\nConvert inner error using <code>From</code>.\nCheck whether <code>self</code> was defined or is a default/unknown span\nLength in code units (in bytes) of the span.\n1-based line number.\n1-based column in code units (in bytes) of the start of …\nReturn a <code>SourceLocation</code> for this span in the provided …\nReturn a <code>SourceLocation</code> for our first span, if we have one.\nCreates a new <code>Span</code> from a range of byte indices\nCreate a new <code>WithSpan</code> from an <code>Error</code>, containing no spans.\n0-based Offset in code units (in bytes) of the start of …\nIterator over stored <code>SpanContext</code>s.\nModifies <code>self</code> to contain the smallest <code>Span</code> possible that …\nConverts <code>self</code> to a range if the span is not unknown\nReturns the smallest <code>Span</code> possible that contains all the …\nReturns a new <code>Span</code> starting at <code>self</code> and ending at <code>other</code>\nAdd a <code>SpanContext</code>.\nAdd a <code>Handle</code> from either <code>Arena</code> or <code>UniqueArena</code>, borrowing …\nSee <code>WithSpan::new</code>.\nAdd a new span with description.\nSee <code>WithSpan::with_context</code>.\nSee <code>WithSpan::with_handle</code>.\nSee <code>WithSpan::with_span</code>.\nreductions, scans\nballot, broadcast\nBarriers\nGroup, binding, and location attributes.\nStatements and blocks of them.\nSupport for <code>BuiltIn::ClipDistance</code>.\nConstants.\nUniformity of control flow for operations that require it.\nSupport for arrayed cube textures.\nSupport for <code>BuiltIn::CullDistance</code>.\nAllowed IR capabilities.\nSupport for generating two sources for blending from …\nSupport for <code>early_depth_test</code>.\nExpressions.\nInformation about an expression in a function body.\nFloat values with width = 8.\nIndicates how a global variable is used.\nMaximum size of a type, in bytes.\nSupport for task shaders, mesh shaders, and per-primitive …\nSupport for mesh shaders which output points.\nSupport for <code>BuiltIn::SampleIndex</code> and <code>Sampling::Sample</code>.\nSupport for <code>BuiltIn::ViewIndex</code>.\nSupport for <code>BuiltIn::PrimitiveIndex</code>.\nSupport for <code>AddressSpace::PushConstant</code>.\nQuad supported\nSupport for ray queries returning vertex position\nSupport for ray queries and acceleration structures.\nSupport for non-uniform indexing of sampled textures and …\nSupport for non-uniform indexing of samplers.\nSupport for fragment shader barycentric coordinates.\nSupport for 16-bit floating-point types.\nSupport for <code>quantizeToF16</code>, <code>pack2x16float</code>, and …\nSupport for <code>AtomicFunction::Add</code>, <code>AtomicFunction::Sub</code>, and …\nSupport for 64-bit signed and unsigned integers.\nSupport for all atomic operations on 64-bit integers.\nSupport for <code>AtomicFunction::Min</code> and <code>AtomicFunction::Max</code> on …\nshuffle, shuffle xor\nshuffle up, down\nSupport for 16-bit normalized storage texture formats.\nSupport for non-uniform indexing of storage texture arrays.\nHost-shareable structure layouts.\nSupport for subgroup operations (except barriers) in …\nSupport for subgroup barriers in compute shaders.\nSupport for subgroup operations (not including barriers) …\nValidation flags.\nSupported subgroup operations\nSupport for atomic operations on images.\nSupport for [<code>ImageClass::External</code>]\nSupport for atomic operations on 64-bit images.\nFlags associated with <code>Type</code>s by <code>Validator</code>.\nSupport for non-uniform indexing of uniform buffer arrays.\nUniform control flow characteristics.\nKinds of expressions that require uniform control flow.\nAny, All\nValidation flags.\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nModule analyzer.\nThe global variable into which this expression produces a …\nSet of shader stages where calling this function is valid.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nGet the underlying bits value.\nGet the underlying bits value.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nCheck whether <code>scalar</code> is a permitted scalar width.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nThe leaf of all module-wide diagnostic filter rules tree …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nIndicates that the function is using dual source blending.\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nInformation about each expression in this function’s …\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nValidation flags.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nHow this function and its callees use this module’s …\nImplementation of <code>Validator::validate_module_handles</code>.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nFunction may kill the invocation.\nA checklist of expressions that must be visited by a …\nCreate a validator for Naga <code>Module</code>s.\nA child expression with non-uniform result.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nTreat overrides whose initializers are not fully-evaluated …\nPopulates <code>self.const_expression_types</code>\nBuilds the <code>FunctionInfo</code> based on the function, and …\nThe number of direct references to this expression in …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nIf this expression requires uniform control flow, store …\nReset the validator internals\nAll (texture, sampler) pairs that may be used together in …\nAll pairs of (texture, sampler) globals that may be used …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe type of this expression.\nWhether this expression is uniform, and why.\nUniformity characteristics.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nCheck the given module to be valid.\nValidate all handles that occur in <code>expression</code>, whose …\nValidate the mesh shader output type <code>ty</code>, used as …\nValidates that all handles within <code>module</code> are:\nCheck the given module to be valid, requiring overrides to …\nValidate all handles that occur in <code>ty</code>, whose handle is …\nAtomic operations will be performed on the variable.\nInformation about an expression in a function body.\nUniformity characteristics of a function.\nIndicates how a global variable is used.\nControl flow may be killed. Anything after <code>Statement::Kill</code> …\nControl flow may return from the function, which makes all …\nNo value.\nThe information about the data is queried.\nData will be read from the variable.\nSome value of type <code>T</code>.\nUniform control flow characteristics.\nDisruptor of the uniform control flow.\nKinds of expressions that require uniform control flow.\nData will be written to the variable.\nRecord a use of <code>expr</code>, and indicate which global variable it\nRecord a use of <code>expr</code> for its value.\nRecord a use of <code>expr</code> of the sort given by <code>global_use</code>.\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nThe global variable into which this expression produces a …\nSet of shader stages where calling this function is valid.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nGet the underlying bits value.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nThe leaf of all module-wide diagnostic filter rules tree …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nIndicates that the function is using dual source blending.\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nReturns a disruptor based on the stored exit flags, if any.\nInformation about each expression in this function’s …\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nValidation flags.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nHow this function and its callees use this module’s …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nNote an entry point’s use of <code>global</code> not recorded by …\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nFunction may kill the invocation.\nA child expression with non-uniform result.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nAnalyzes the uniformity requirements of a block (as a …\nInherit information from a called function.\nCompute the <code>ExpressionInfo</code> for <code>handle</code>.\nThe number of direct references to this expression in …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nIf this expression requires uniform control flow, store …\nAll (texture, sampler) pairs that may be used together in …\nAll pairs of (texture, sampler) globals that may be used …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe type of this expression.\nWhether this expression is uniform, and why.\nUniformity characteristics.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe control can break.\nThe control can continue.\nThe control can return out of this block.\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis type can be passed as a function argument.\nA WGSL constructible type.\nThe data can be copied around.\nThe set of types with a fixed size at shader-creation time …\nCan be used for data variables.\nContains the error value\nContains the error value\nCan be used for host-shareable structures.\nCan be be used for user-defined IO between pipeline stages.\nContains the success value\nContains the success value\nThe data type has a size known by pipeline creation time.\nFlags associated with <code>Type</code>s by <code>Validator</code>.\nGet a flags value with all known bits set.\nGet the underlying bits value.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nGet a flags value with the bits of a flag with the given …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nDetermine whether a pointer in <code>space</code> can be passed as an …\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.")