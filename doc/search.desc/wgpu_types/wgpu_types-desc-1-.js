searchState.loadedDescShard("wgpu_types", 1, "4x4 block compressed texture. 16 bytes per block (8 …\nBlue, green, red, and alpha channels. 8 bit integer per …\nBlue, green, red, and alpha channels. 8 bit integer per …\nSpecial depth format with 16 bit integer depth.\nSpecial depth format with at least 24 bit integer depth.\nSpecial depth/stencil format with at least 24 bit integer …\nSpecial depth format with 32 bit floating point depth.\nSpecial depth/stencil format with 32 bit floating point …\n4x4 block compressed texture. 8 bytes per block (4 …\n4x4 block compressed texture. 8 bytes per block (4 …\n4x4 block compressed texture. 16 bytes per block (8 …\n4x4 block compressed texture. 16 bytes per block (8 …\n4x4 block compressed texture. 8 bytes per block (4 …\n4x4 block compressed texture. 8 bytes per block (4 …\n4x4 block compressed texture. 8 bytes per block (4 …\n4x4 block compressed texture. 8 bytes per block (4 …\n4x4 block compressed texture. 16 bytes per block (8 …\n4x4 block compressed texture. 16 bytes per block (8 …\nIf not present, the texture can’t be sampled with a …\nfloating-point RGBA, linear-color float can be outside of …\nThe largest number that can be returned by …\nAllows a texture of this format to back a view passed as …\nAllows [<code>TextureDescriptor::sample_count</code>] to be <code>16</code>.\nAllows [<code>TextureDescriptor::sample_count</code>] to be <code>2</code>.\nAllows [<code>TextureDescriptor::sample_count</code>] to be <code>4</code>.\nAllows [<code>TextureDescriptor::sample_count</code>] to be <code>8</code>.\nYUV 4:2:0 chroma subsampled format.\nYUV 4:2:0 chroma subsampled format.\nRed channel only. 16 bit float per channel. Float in …\nRed channel only. 16 bit integer per channel. Signed in …\nRed channel only. 16 bit integer per channel. [−32767, …\nRed channel only. 16 bit integer per channel. Unsigned in …\nRed channel only. 16 bit integer per channel. [0, 65535] …\nRed channel only. 32 bit float per channel. Float in …\nRed channel only. 32 bit integer per channel. Signed in …\nRed channel only. 32 bit integer per channel. Unsigned in …\nRed channel only. 64 bit integer per channel. Unsigned in …\nRed channel only. 8 bit integer per channel. Signed in …\nRed channel only. 8 bit integer per channel. [−127, 127] …\nRed channel only. 8 bit integer per channel. Unsigned in …\nRed channel only. 8 bit integer per channel. [0, 255] …\nRed, green, and blue channels. 11 bit float with no sign …\nRed and green channels. 16 bit float per channel. Float in …\nRed and green channels. 16 bit integer per channel. Signed …\nRed and green channels. 16 bit integer per channel. [−…\nRed and green channels. 16 bit integer per channel. …\nRed and green channels. 16 bit integer per channel. [0, …\nRed and green channels. 32 bit float per channel. Float in …\nRed and green channels. 32 bit integer per channel. Signed …\nRed and green channels. 32 bit integer per channel. …\nRed and green channels. 8 bit integer per channel. Signed …\nRed and green channels. 8 bit integer per channel. [−…\nRed and green channels. 8 bit integer per channel. …\nRed and green channels. 8 bit integer per channel. [0, 255]…\nRed, green, blue, and alpha channels. 10 bit integer for …\nRed, green, blue, and alpha channels. 10 bit integer for …\nPacked unsigned float with 9 bits mantisa for each RGB …\nRed, green, blue, and alpha channels. 16 bit float per …\nRed, green, blue, and alpha channels. 16 bit integer per …\nRed, green, blue, and alpha. 16 bit integer per channel. […\nRed, green, blue, and alpha channels. 16 bit integer per …\nRed, green, blue, and alpha channels. 16 bit integer per …\nRed, green, blue, and alpha channels. 32 bit float per …\nRed, green, blue, and alpha channels. 32 bit integer per …\nRed, green, blue, and alpha channels. 32 bit integer per …\nRed, green, blue, and alpha channels. 8 bit integer per …\nRed, green, blue, and alpha channels. 8 bit integer per …\nRed, green, blue, and alpha channels. 8 bit integer per …\nRed, green, blue, and alpha channels. 8 bit integer per …\nRed, green, blue, and alpha channels. 8 bit integer per …\nWhen used as a STORAGE texture, then a texture with this …\nWhen used as a STORAGE texture, then a texture with this …\nWhen used as a STORAGE texture, then a texture with this …\nWhen used as a STORAGE texture, then a texture with this …\nStencil format with 8 bit integer stencil.\nFormat in which a texture’s texels are stored in GPU …\nFeature flags for a texture format.\nFeatures supported by a given texture format\n8 bit integer RGBA, [0, 255] converted to/from …\n8 bit integer RGBA, Srgb-color [0, 255] converted to/from …\nAdds an <code>Srgb</code> suffix to the given texture format, if the …\nGet a flags value with all known bits set.\nValid bits for <code>TextureDescriptor::Usage</code> provided for …\nReturns the aspect-specific format of the original format\nGet the underlying bits value.\nThe number of bytes one texel block occupies during an …\nReturns the dimension of a block of texels.\nThe number of bytes one texel block occupies during an …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nReturns the number of components this format has.\nReturns the number of components this format has taking …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nAdditional property flags for the format.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nGet a flags value with the bits of a flag with the given …\nReturns the format features guaranteed by the WebGPU spec.\nReturns <code>true</code> if the format has a color aspect\nReturns <code>true</code> if the format has a depth aspect\nReturns <code>true</code> if the format has a stencil aspect\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nWhether all known bits in this flags value are set.\nReturns <code>true</code> for ASTC compressed formats.\nReturns <code>true</code> for BCn compressed formats.\nReturns <code>true</code> if the format is a combined depth-stencil …\nReturns <code>true</code> for compressed formats.\nReturns <code>true</code> if <code>self</code> is a depth or stencil component of …\nReturns <code>true</code> if the format is a depth and/or stencil format\nWhether all bits in this flags value are unset.\nReturns <code>true</code> if the format is a multi-planar format\nReturns <code>true</code> for srgb formats.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nReturns the number of planes a multi-planar format has.\nThe intersection of a source flags value with the …\nStrips the <code>Srgb</code> suffix from the given texture format.\nReturns the required features (if any) in order to use the …\nSample count supported by a given texture format.\nReturns the sample type compatible with this format and …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nReturns the size multiple requirement for a texture using …\nReturns the subsampling factor for the indicated plane of …\nA <code>Vec</code> of supported sample counts.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nSee …\nThe number of bytes occupied per pixel in a color …\nReturns the theoretical memory footprint of a texture with …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\ncompressed block dimensions\nASTC RGBA channel\nToken of the user agreeing to access experimental features.\nToken of the user agreeing to use <code>LoadOp::DontCare</code>.\nUses of <code>Features</code> prefixed with “EXPERIMENTAL” are …\nUses of <code>Features</code> prefixed with “EXPERIMENTAL” may …\nUsing <code>LoadOp::DontCare</code> will result in the render target …\nReturns true if the user has agreed to access experimental …\nThe total size of the copy overflows a <code>u64</code>.\nThe total size of the copy overflows a <code>u64</code>.\nInformation about a copy between a buffer and a texture.\nErrors that can occur while populating …\nThe last-layer byte size overflows a <code>u64</code>.\nThe last-layer byte size overflows a <code>u64</code>.\nThe image stride overflows a <code>u64</code>.\nThe image stride overflows a <code>u64</code>.\nThe <code>bytes_per_row</code> is too small for the texture width.\nThe <code>bytes_per_row</code> is too small for the texture width.\nThe <code>rows_per_image</code> is too small for the texture height.\nThe <code>rows_per_image</code> is too small for the texture height.\nThe number of texel in a texel block in the y direction.\nThe size of a single texture texel block in bytes.\nThe number of texel in a texel block in the x direction.\nThe total number of bytes in the copy region.\nThe height of the copy region in pixels.\nThe width of the copy region in pixels.\nThe depth of the copy region in pixels.\nThe height of the copy region in blocks.\nThe number of bytes in a densely packed list of images.\nThe number of rows in a densely packed list of images.\nThe stride in bytes between the start of one image and the …\nThe stride in rows between the start of one image and the …\nThe offset in the buffer where the copy starts.\nThe number of bytes in the last row of the copy region.\nThe stride in bytes between the start of one row in an …\nThe width of the copy region in blocks.\nOne half-precision float (no Rust equiv). <code>f32</code> in shaders.\nTwo half-precision floats (no Rust equiv). <code>vec2&lt;f32&gt;</code> in …\nFour half-precision floats (no Rust equiv). <code>vec4&lt;f32&gt;</code> in …\nOne single-precision float (f32). <code>f32</code> in shaders.\nTwo single-precision floats (f32). <code>vec2&lt;f32&gt;</code> in shaders.\nThree single-precision floats (f32). <code>vec3&lt;f32&gt;</code> in shaders.\nFour single-precision floats (f32). <code>vec4&lt;f32&gt;</code> in shaders.\nOne double-precision float (f64). <code>f32</code> in shaders. Requires …\nTwo double-precision floats (f64). <code>vec2&lt;f32&gt;</code> in shaders. …\nThree double-precision floats (f64). <code>vec3&lt;f32&gt;</code> in shaders. …\nFour double-precision floats (f64). <code>vec4&lt;f32&gt;</code> in shaders. …\nVertex data is advanced every instance.\nOne signed short (u16). <code>i32</code> in shaders.\nTwo signed shorts (i16). <code>vec2&lt;i32&gt;</code> in shaders.\nFour signed shorts (i16). <code>vec4&lt;i32&gt;</code> in shaders.\nOne signed int (i32). <code>i32</code> in shaders.\nTwo signed ints (i32). <code>vec2&lt;i32&gt;</code> in shaders.\nThree signed ints (i32). <code>vec3&lt;i32&gt;</code> in shaders.\nFour signed ints (i32). <code>vec4&lt;i32&gt;</code> in shaders.\nOne signed byte (i8). <code>i32</code> in shaders.\nTwo signed bytes (i8). <code>vec2&lt;i32&gt;</code> in shaders.\nFour signed bytes (i8). <code>vec4&lt;i32&gt;</code> in shaders.\nOne signed short (i16). [−32767, 32767] converted to …\nTwo signed shorts (i16). [−32767, 32767] converted to …\nFour signed shorts (i16). [−32767, 32767] converted to …\nOne signed byte (i8). [−127, 127] converted to float [−…\nTwo signed bytes (i8). [−127, 127] converted to float […\nFour signed bytes (i8). [−127, 127] converted to float […\nOne unsigned short (u16). <code>u32</code> in shaders.\nTwo unsigned shorts (u16). <code>vec2&lt;u32&gt;</code> in shaders.\nFour unsigned shorts (u16). <code>vec4&lt;u32&gt;</code> in shaders.\nOne unsigned int (u32). <code>u32</code> in shaders.\nTwo unsigned ints (u32). <code>vec2&lt;u32&gt;</code> in shaders.\nThree unsigned ints (u32). <code>vec3&lt;u32&gt;</code> in shaders.\nFour unsigned ints (u32). <code>vec4&lt;u32&gt;</code> in shaders.\nOne unsigned byte (u8). <code>u32</code> in shaders.\nTwo unsigned bytes (u8). <code>vec2&lt;u32&gt;</code> in shaders.\nFour unsigned bytes (u8). <code>vec4&lt;u32&gt;</code> in shaders.\nThree unsigned 10-bit integers and one 2-bit integer, …\nOne unsigned short (u16). [0, 65535] converted to float […\nTwo unsigned shorts (u16). [0, 65535] converted to float […\nFour unsigned shorts (u16). [0, 65535] converted to float […\nOne unsigned byte (u8). [0, 255] converted to float [0, 1] …\nTwo unsigned bytes (u8). [0, 255] converted to float [0, 1]…\nFour unsigned bytes (u8). [0, 255] converted to float [0, 1…\nFour unsigned 8-bit integers, packed into a 32-bit integer …\nVertex data is advanced every vertex.\nVertex inputs (attributes) to shaders.\nVertex Format for a <code>VertexAttribute</code> (input).\nWhether a vertex buffer is indexed by vertex or by …\nReturns the alignment required for …\nFormat of the input\nReturns the size read by an acceleration structure build …\nByte offset of the start of the input\nLocation for this input. Must match the location in the …\nReturns the byte size of the format.")