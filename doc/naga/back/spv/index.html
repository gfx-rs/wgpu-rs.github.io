<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Backend for SPIR-V (Standard Portable Intermediate Representation)."><title>naga::back::spv - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="naga" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0 (ded5c06cf 2025-12-08)" data-channel="1.92.0" data-search-js="search-d69d8955.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module spv</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../naga/index.html">naga</a><span class="version">28.0.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module spv</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#layout-of-values-in-uniform-buffers" title="Layout of values in `uniform` buffers">Layout of values in <code>uniform</code> buffers</a><ul><li><a href="#padding-in-two-row-matrices" title="Padding in two-row matrices">Padding in two-row matrices</a></li></ul></li></ul><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In naga::<wbr>back</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">naga</a>::<wbr><a href="../index.html">back</a></div><h1>Module <span>spv</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/naga/back/spv/mod.rs.html#1-1130">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Backend for <a href="https://www.khronos.org/registry/SPIR-V/">SPIR-V</a> (Standard Portable Intermediate Representation).</p>
<h2 id="layout-of-values-in-uniform-buffers"><a class="doc-anchor" href="#layout-of-values-in-uniform-buffers">Â§</a>Layout of values in <code>uniform</code> buffers</h2>
<p>WGSLâ€™s <a href="https://gpuweb.github.io/gpuweb/wgsl/#internal-value-layout">â€œInternal Layout of Valuesâ€</a> rules specify the memory layout of
each WGSL type. The memory layout is important for data stored in <code>uniform</code> and
<code>storage</code> buffers, especially when exchanging data with CPU code.</p>
<p>Both WGSL and Vulkan specify some conditions that a typeâ€™s memory layout
must satisfy in order to use that type in a <code>uniform</code> or <code>storage</code> buffer.
For <code>storage</code> buffers, the WGSL and Vulkan restrictions are compatible, but
for <code>uniform</code> buffers, WGSL allows some types that Vulkan does not, requiring
adjustments when emitting SPIR-V for <code>uniform</code> buffers.</p>
<h3 id="padding-in-two-row-matrices"><a class="doc-anchor" href="#padding-in-two-row-matrices">Â§</a>Padding in two-row matrices</h3>
<p>SPIR-V provides detailed control over the layout of matrix types, and is
capable of describing the WGSL memory layout. However, Vulkan imposes
additional restrictions.</p>
<p>Vulkanâ€™s <a href="https://docs.vulkan.org/spec/latest/chapters/interfaces.html#interfaces-resources-layout">â€œextended layoutâ€</a> (also known as std140) rules
apply to types used in <code>uniform</code> buffers. Under these rules, matrices are
defined in terms of arrays of their vector type, and arrays are defined to have
an alignment equal to the alignment of their element type rounded up to a
multiple of 16. This means that each column of the matrix has a minimum
alignment of 16. WGSL, and consequently Naga IR, on the other hand specifies
column alignment equal to the alignment of the vector type, without being
rounded up to 16.</p>
<p>To compensate for this, for any <code>struct</code> used as a <code>uniform</code> buffer which
contains a two-row matrix, we declare an additional â€œstd140 compatibleâ€ type
in which each column of the matrix has been decomposed into the containing
struct. For example, the following WGSL struct type:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">â“˜</a><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>Baz {
    m: mat3x2&lt;f32&gt;,
}</code></pre></div>
<p>is rendered as the SPIR-V struct type:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">â“˜</a><pre class="rust rust-example-rendered"><code>OpTypeStruct %v2float %v2float %v2float</code></pre></div>
<p>This has the effect that struct indices in Naga IR for such types do not
correspond to the struct indices used in SPIR-V. A mapping of struct indices
for these types is maintained in <a href="struct.Std140CompatTypeInfo.html" title="struct naga::back::spv::Std140CompatTypeInfo"><code>Std140CompatTypeInfo</code></a>.</p>
<p>Additionally, any two-row matrices that are declared directly as uniform
buffers without being wrapped in a struct are declared as a struct containing a
vector member for each column. Any array of a two-row matrix in a uniform
buffer is declared as an array of a struct containing a vector member for each
column. Any struct or array within a uniform buffer which contains a member or
whose base type requires a std140 compatible type declaration, itself requires a
std140 compatible type declaration.</p>
<p>Whenever a value of such a type is <a href="../../ir/enum.Expression.html#variant.Load" title="variant naga::ir::Expression::Load"><code>loaded</code></a> we insert code to convert the
loaded value from the std140 compatible type to the regular type. This occurs
in <code>BlockContext::write_checked_load</code>, making use of the wrapper function
defined by <code>Writer::write_wrapped_convert_from_std140_compat_type</code>. For matrices
that have been decomposed as separate columns in the containing struct, we load
each column separately then composite the matrix type in
<code>BlockContext::maybe_write_load_uniform_matcx2_struct_member</code>.</p>
<p>Whenever a column of a matrix that has been decomposed into its containing
struct is <a href="../../ir/enum.Expression.html#variant.AccessIndex" title="variant naga::ir::Expression::AccessIndex"><code>accessed</code></a> with a constant index we adjust the emitted access chain
to access from the containing struct instead, in <code>BlockContext::write_access_chain</code>.</p>
<p>Whenever a column of a uniform buffer two-row matrix is <a href="../../ir/enum.Expression.html#variant.Access" title="variant naga::ir::Expression::Access"><code>dynamically accessed</code></a>
we must first load the matrix type, converting it from its std140 compatible
type as described above, then access the column using the wrapper function
defined by <code>Writer::write_wrapped_matcx2_get_column</code>. This is handled by
<code>BlockContext::maybe_write_uniform_matcx2_dynamic_access</code>.</p>
<p>Note that this approach differs somewhat from the equivalent code in the HLSL
backend. For HLSL all structs containing two-row matrices (or arrays of such)
have their declarations modified, not just those used as uniform buffers.
Two-row matrices and arrays of such only use modified type declarations when
used as uniform buffers, or additionally when used as struct member in any
context. This avoids the need to convert struct values when loading from uniform
buffers, but when loading arrays and matrices from uniform buffers or from any
struct the conversion is still required. In contrast, the approach used here
always requires converting <em>any</em> affected type when loading from a uniform
buffer, but consistently <em>only</em> when loading from a uniform buffer. As a result
this also means we only have to handle loads and not stores, as uniform buffers
are read-only.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="mod" href="block/index.html" title="mod naga::back::spv::block">block</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Implementations for <code>BlockContext</code> methods.</dd><dt><a class="mod" href="f16_polyfill/index.html" title="mod naga::back::spv::f16_polyfill">f16_<wbr>polyfill</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>This module provides functionality for polyfilling <code>f16</code> input/output variables
when the <code>StorageInputOutput16</code> capability is not available or disabled.</dd><dt><a class="mod" href="helpers/index.html" title="mod naga::back::spv::helpers">helpers</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="mod" href="image/index.html" title="mod naga::back::spv::image">image</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Generating SPIR-V for image operations.</dd><dt><a class="mod" href="index/index.html" title="mod naga::back::spv::index">index</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Bounds-checking for SPIR-V output.</dd><dt><a class="mod" href="instructions/index.html" title="mod naga::back::spv::instructions">instructions</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="mod" href="layout/index.html" title="mod naga::back::spv::layout">layout</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="mod" href="mesh_shader/index.html" title="mod naga::back::spv::mesh_shader">mesh_<wbr>shader</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="mod" href="ray/index.html" title="mod naga::back::spv::ray">ray</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Module for code shared between ray queries and ray tracing pipeline code.
Ray tracing pipelines are not yet implemented, so this is empty.</dd><dt><a class="mod" href="recyclable/index.html" title="mod naga::back::spv::recyclable">recyclable</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Reusing collectionsâ€™ previous allocations.</dd><dt><a class="mod" href="selection/index.html" title="mod naga::back::spv::selection">selection</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Generate SPIR-V conditional structures.</dd><dt><a class="mod" href="subgroup/index.html" title="mod naga::back::spv::subgroup">subgroup</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="mod" href="writer/index.html" title="mod naga::back::spv::writer">writer</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.BindingInfo.html" title="struct naga::back::spv::BindingInfo">Binding<wbr>Info</a></dt><dt><a class="struct" href="struct.Block.html" title="struct naga::back::spv::Block">Block</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>A SPIR-V block to which we are still adding instructions.</dd><dt><a class="struct" href="struct.BlockContext.html" title="struct naga::back::spv::BlockContext">Block<wbr>Context</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>General information needed to emit SPIR-V for Naga statements.</dd><dt><a class="struct" href="struct.CachedExpressions.html" title="struct naga::back::spv::CachedExpressions">Cached<wbr>Expressions</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>A map from evaluated <a href="../../ir/enum.Expression.html" title="enum naga::ir::Expression"><code>Expression</code></a>s to their SPIR-V ids.</dd><dt><a class="struct" href="struct.DebugInfo.html" title="struct naga::back::spv::DebugInfo">Debug<wbr>Info</a></dt><dt><a class="struct" href="struct.EntryPointContext.html" title="struct naga::back::spv::EntryPointContext">Entry<wbr>Point<wbr>Context</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="struct" href="struct.ExpressionConstnessTracker.html" title="struct naga::back::spv::ExpressionConstnessTracker">Expression<wbr>Constness<wbr>Tracker</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Tracks the expressions for which the backend emits the following instructions:</dd><dt><a class="struct" href="struct.Function.html" title="struct naga::back::spv::Function">Function</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="struct" href="struct.FunctionArgument.html" title="struct naga::back::spv::FunctionArgument">Function<wbr>Argument</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="struct" href="struct.GlobalVariable.html" title="struct naga::back::spv::GlobalVariable">Global<wbr>Variable</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>The SPIR-V representation of a <a href="../../ir/struct.GlobalVariable.html" title="struct naga::ir::GlobalVariable"><code>crate::GlobalVariable</code></a>.</dd><dt><a class="struct" href="struct.IdGenerator.html" title="struct naga::back::spv::IdGenerator">IdGenerator</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="struct" href="struct.ImageTypeFlags.html" title="struct naga::back::spv::ImageTypeFlags">Image<wbr>Type<wbr>Flags</a></dt><dd>Flags corresponding to the boolean(-ish) parameters to OpTypeImage.</dd><dt><a class="struct" href="struct.Instruction.html" title="struct naga::back::spv::Instruction">Instruction</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="struct" href="struct.LocalImageType.html" title="struct naga::back::spv::LocalImageType">Local<wbr>Image<wbr>Type</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Characteristics of a SPIR-V <code>OpTypeImage</code> type.</dd><dt><a class="struct" href="struct.LocalVariable.html" title="struct naga::back::spv::LocalVariable">Local<wbr>Variable</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="struct" href="struct.LogicalLayout.html" title="struct naga::back::spv::LogicalLayout">Logical<wbr>Layout</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="struct" href="struct.LookupFunctionType.html" title="struct naga::back::spv::LookupFunctionType">Lookup<wbr>Function<wbr>Type</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="struct" href="struct.MeshReturnInfo.html" title="struct naga::back::spv::MeshReturnInfo">Mesh<wbr>Return<wbr>Info</a></dt><dt><a class="struct" href="struct.MeshReturnMember.html" title="struct naga::back::spv::MeshReturnMember">Mesh<wbr>Return<wbr>Member</a></dt><dt><a class="struct" href="struct.Options.html" title="struct naga::back::spv::Options">Options</a></dt><dt><a class="struct" href="struct.PhysicalLayout.html" title="struct naga::back::spv::PhysicalLayout">Physical<wbr>Layout</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="struct" href="struct.PipelineOptions.html" title="struct naga::back::spv::PipelineOptions">Pipeline<wbr>Options</a></dt><dt><a class="struct" href="struct.RayQueryTrackers.html" title="struct naga::back::spv::RayQueryTrackers">RayQuery<wbr>Trackers</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="struct" href="struct.ResultMember.html" title="struct naga::back::spv::ResultMember">Result<wbr>Member</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="struct" href="struct.Std140CompatTypeInfo.html" title="struct naga::back::spv::Std140CompatTypeInfo">Std140<wbr>Compat<wbr>Type<wbr>Info</a></dt><dd>Information about a type for which we have declared a std140 layout
compatible variant, because the type is used in a uniform but does not
adhere to std140 requirements. The uniform will be declared using the
type <code>type_id</code>, and the result of any <code>Load</code> will be immediately converted
to the base type. This is used for matrices with 2 rows, as well as any
arrays or structs containing such matrices.</dd><dt><a class="struct" href="struct.TerminatedBlock.html" title="struct naga::back::spv::TerminatedBlock">Terminated<wbr>Block</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>A SPIR-V block that ends with a termination instruction.</dd><dt><a class="struct" href="struct.Writer.html" title="struct naga::back::spv::Writer">Writer</a></dt><dt><a class="struct" href="struct.WriterFlags.html" title="struct naga::back::spv::WriterFlags">Writer<wbr>Flags</a></dt></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.CachedConstant.html" title="enum naga::back::spv::CachedConstant">Cached<wbr>Constant</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="enum" href="enum.Capability.html" title="enum naga::back::spv::Capability">Capability</a></dt><dd>SPIR-V operand kind: <a href="https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#_a_id_capability_a_capability">Capability</a></dd><dt><a class="enum" href="enum.CooperativeType.html" title="enum naga::back::spv::CooperativeType">Cooperative<wbr>Type</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>A cooperative type, for use in <a href="enum.LocalType.html" title="enum naga::back::spv::LocalType"><code>LocalType</code></a>.</dd><dt><a class="enum" href="enum.Dimension.html" title="enum naga::back::spv::Dimension">Dimension</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="enum" href="enum.Error.html" title="enum naga::back::spv::Error">Error</a></dt><dt><a class="enum" href="enum.LocalType.html" title="enum naga::back::spv::LocalType">Local<wbr>Type</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>A SPIR-V type constructed during code generation.</dd><dt><a class="enum" href="enum.LookupRayQueryFunction.html" title="enum naga::back::spv::LookupRayQueryFunction">Lookup<wbr>RayQuery<wbr>Function</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="enum" href="enum.LookupType.html" title="enum naga::back::spv::LookupType">Lookup<wbr>Type</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>A type encountered during SPIR-V generation.</dd><dt><a class="enum" href="enum.NumericType.html" title="enum naga::back::spv::NumericType">Numeric<wbr>Type</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>A numeric type, for use in <a href="enum.LocalType.html" title="enum naga::back::spv::LocalType"><code>LocalType</code></a>.</dd><dt><a class="enum" href="enum.SourceLanguage.html" title="enum naga::back::spv::SourceLanguage">Source<wbr>Language</a></dt><dd>SPIR-V operand kind: <a href="https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#_a_id_source_language_a_source_language">SourceLanguage</a></dd><dt><a class="enum" href="enum.WrappedFunction.html" title="enum naga::back::spv::WrappedFunction">Wrapped<wbr>Function</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Key used to look up an operation which we have wrapped in a helper
function, which should be called instead of directly emitting code
for the expression. See <a href="struct.Writer.html#structfield.wrapped_functions" title="field naga::back::spv::Writer::wrapped_functions"><code>Writer::wrapped_functions</code></a>.</dd><dt><a class="enum" href="enum.ZeroInitializeWorkgroupMemoryMode.html" title="enum naga::back::spv::ZeroInitializeWorkgroupMemoryMode">Zero<wbr>Initialize<wbr>Workgroup<wbr>Memory<wbr>Mode</a></dt></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="constant" href="constant.BITS_PER_BYTE.html" title="constant naga::back::spv::BITS_PER_BYTE">BITS_<wbr>PER_<wbr>BYTE</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.write_vec.html" title="fn naga::back::spv::write_vec">write_<wbr>vec</a></dt></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="type" href="type.BindingMap.html" title="type naga::back::spv::BindingMap">Binding<wbr>Map</a></dt></dl></section></div></main></body></html>