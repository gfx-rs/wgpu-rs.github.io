<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Build a set of expressions used as indices, to cache in temporary variables when emitted."><title>find_checked_indexes in naga::proc::index - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e6a78389201e676c.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="naga" data-themes="" data-resource-suffix="" data-rustdoc-version="1.76.0-nightly (87e1447aa 2023-11-30)" data-channel="nightly" data-search-js="search-5a66c239c06b3a66.js" data-settings-js="settings-fe03fdc259827cd2.js" ><script src="../../../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-77dede896d6ac08e.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../naga/index.html">naga</a><span class="version">0.14.0</span></h2></div><div class="sidebar-elems"><h2><a href="index.html">In naga::proc::index</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Function <a href="../../index.html">naga</a>::<wbr><a href="../index.html">proc</a>::<wbr><a href="index.html">index</a>::<wbr><a class="fn" href="#">find_checked_indexes</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../src/naga/proc/index.rs.html#239-296">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub fn find_checked_indexes(
    module: &amp;<a class="struct" href="../../struct.Module.html" title="struct naga::Module">Module</a>,
    function: &amp;<a class="struct" href="../../struct.Function.html" title="struct naga::Function">Function</a>,
    info: &amp;<a class="struct" href="../../valid/struct.FunctionInfo.html" title="struct naga::valid::FunctionInfo">FunctionInfo</a>,
    policies: <a class="struct" href="struct.BoundsCheckPolicies.html" title="struct naga::proc::index::BoundsCheckPolicies">BoundsCheckPolicies</a>
) -&gt; BitSet</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Build a set of expressions used as indices, to cache in temporary variables when
emitted.</p>
<p>Given the bounds-check policies <code>policies</code>, construct a <code>BitSet</code> containing the handle
indices of all the expressions in <code>function</code> that are ever used as guarded indices
under the <a href="enum.BoundsCheckPolicy.html#variant.ReadZeroSkipWrite" title="variant naga::proc::index::BoundsCheckPolicy::ReadZeroSkipWrite"><code>ReadZeroSkipWrite</code></a> policy. The <code>module</code> argument must be the module to
which <code>function</code> belongs, and <code>info</code> should be that function’s analysis results.</p>
<p>Such index expressions will be used twice in the generated code: first for the
comparison to see if the index is in bounds, and then for the access itself, should
the comparison succeed. To avoid computing the expressions twice, the generated code
should cache them in temporary variables.</p>
<p>Why do we need to build such a set in advance, instead of just processing access
expressions as we encounter them? Whether an expression needs to be cached depends on
whether it appears as something like the <a href="../../enum.Expression.html#variant.Access.field.index" title="field naga::Expression::index"><code>index</code></a> operand of an <a href="../../enum.Expression.html#variant.Access" title="variant naga::Expression::Access"><code>Access</code></a> expression
or the <a href="../../enum.Expression.html#variant.ImageLoad.field.level" title="field naga::Expression::level"><code>level</code></a> operand of an <a href="../../enum.Expression.html#variant.ImageLoad" title="variant naga::Expression::ImageLoad"><code>ImageLoad</code></a> expression, and on the index bounds check
policies that apply to those accesses. But <a href="../../enum.Statement.html#variant.Emit" title="variant naga::Statement::Emit"><code>Emit</code></a> statements just identify a range
of expressions by index; there’s no good way to tell what an expression is used
for. The only way to do it is to just iterate over all the expressions looking for
relevant <code>Access</code> expressions — which is what this function does.</p>
<p>Simple expressions like variable loads and constants don’t make sense to cache: it’s
no better than just re-evaluating them. But constants are not covered by <code>Emit</code>
statements, and <code>Load</code>s are always cached to ensure they occur at the right time, so
we don’t bother filtering them out from this set.</p>
<p>Fortunately, we don’t need to deal with <a href="../../enum.Statement.html#variant.ImageStore" title="variant naga::Statement::ImageStore"><code>ImageStore</code></a> statements here. When we emit
code for a statement, the writer isn’t in the middle of an expression, so we can just
emit declarations for temporaries, initialized appropriately.</p>
<p>None of these concerns apply for SPIR-V output, since it’s easy to just reuse an
instruction ID in two places; that has the same semantics as a temporary variable, and
it’s inherent in the design of SPIR-V. This function is more useful for text-based
back ends.</p>
</div></details></section></div></main></body></html>